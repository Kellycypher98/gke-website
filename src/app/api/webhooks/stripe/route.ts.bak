import { NextResponse } from 'next/server'
import { headers } from 'next/headers'
import { createClient } from '@supabase/supabase-js'
import Stripe from 'stripe'
import { stripe, verifyWebhookSignature } from '@/lib/stripe'

// Initialize Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
)

// Disable body parsing for webhook verification
// This is required to verify the raw body
// @ts-ignore - Next.js 13+ specific
// See: https://nextjs.org/docs/app/building-your-application/routing/route-handlers#streaming
// and: https://github.com/vercel/next.js/discussions/39999
export const config = {
  api: {
    bodyParser: false,
  },
}

// Helper to read the raw body as a string
async function getRawBody(readable: ReadableStream<Uint8Array> | null): Promise<string> {
  if (!readable) {
    throw new Error('Request body is empty')
  }
  
  const reader = readable.getReader()
  const decoder = new TextDecoder()
  let result = ''

  while (true) {
    const { done, value } = await reader.read()
    if (done) break
    result += decoder.decode(value, { stream: true })
  }
  
  return result + decoder.decode()
}

export async function POST(req: Request) {
  console.log('=== WEBHOOK RECEIVED ===');
  console.log('Request headers:', JSON.stringify(Object.fromEntries(req.headers.entries()), null, 2));
  
  try {
    // Get the raw body as text
    const body = await req.text()
    
    if (!body) {
      console.error('‚ùå Empty request body received')
      return new NextResponse('Empty request body', { status: 400 })
    }
    
    console.log('Request body received:', body.substring(0, 500) + (body.length > 500 ? '...' : ''));
    
    const signature = headers().get('stripe-signature')
    console.log('Stripe-Signature header:', signature ? 'present' : 'missing');

    if (!signature) {
      console.error('‚ùå No Stripe signature header found')
      return new NextResponse('No signature', { status: 400 })
    }

    let event: Stripe.Event

    try {
      console.log('üîë Verifying webhook signature...');
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      console.log('Using webhook secret:', webhookSecret ? 'present' : 'missing');
      
      event = stripe.webhooks.constructEvent(
        body,
        signature,
        webhookSecret || ''
      );
      
      console.log('‚úÖ Webhook verified. Event type:', event.type);
      console.log('Event ID:', event.id);
      console.log('Event object:', JSON.stringify(event, null, 2).substring(0, 500) + '...');
      
    } catch (error) {
      console.error('‚ùå Webhook signature verification failed:', error);
      return new NextResponse('Invalid signature', { status: 400 });
    }

    console.log(`Received event type: ${event.type}`)

    // Handle the checkout.session.completed event (both Checkout and Payment Links)
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as Stripe.Checkout.Session
      console.log('=== WEBHOOK RECEIVED: CHECKOUT SESSION COMPLETED ===')
      console.log('Session ID:', session.id)
      console.log('Mode:', session.mode) // payment, subscription, setup, etc.
      console.log('Payment Link ID:', session.payment_link) // Will be present for Payment Links
      console.log('Metadata:', session.metadata)
      console.log('Customer email:', session.customer_details?.email || session.customer_email)
      console.log('Amount total:', session.amount_total)
      
      // Respond immediately and process in the background
      void handleCheckoutSession(session).catch(console.error);
      return NextResponse.json({ received: true });
    }
    // Handle payment_intent.succeeded for Payment Links and other payment methods
    else if (event.type === 'payment_intent.succeeded') {
      const paymentIntent = event.data.object as Stripe.PaymentIntent
      console.log('=== PAYMENT INTENT SUCCEEDED ===')
      console.log('PaymentIntent ID:', paymentIntent.id)
      console.log('Amount:', paymentIntent.amount)
      console.log('Metadata:', paymentIntent.metadata)
      
      try {
        // If this is from a Payment Link, we might need to update an existing order
        if (paymentIntent.metadata?.stripe_session_id) {
          const { data: order, error } = await supabase
            .from('orders')
            .update({
              paymentStatus: 'paid',
              status: 'confirmed',
              paymentIntentId: paymentIntent.id,
              updatedAt: new Date().toISOString()
            })
            .eq('stripeSessionId', paymentIntent.metadata.stripe_session_id)
            .select()
            .single()
            
          if (error) {
            console.error('Error updating order with payment intent:', error)
          } else if (order) {
            console.log('Updated order with payment intent:', order.id)
          }
        }
      } catch (error) {
        console.error('Error processing payment_intent.succeeded:', error)
      }
    }
    // Handle other event types as needed
    // else if (event.type === 'payment_intent.succeeded') { ... }

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error('Error in webhook handler:', error)
    return new NextResponse(
      JSON.stringify({ error: 'Internal Server Error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
}

async function handleCheckoutSession(session: Stripe.Checkout.Session) {
  try {
    // Get the metadata we passed to the Checkout Session
    const metadata = session.metadata || {}
    // Handle both eventId and eventID for backward compatibility
    const eventId = metadata.eventId || metadata.eventID;
    const ticketType = metadata.ticketType || 'standard';
    
    if (!eventId) {
      console.error('Missing eventId in checkout session metadata. Available metadata:', metadata);
      return
    }

    // Get the customer email and name from the session with proper type checking
    const customerEmail = session.customer_details?.email
    const customerName = session.customer_details?.name || undefined
    const amountTotal = session.amount_total ? session.amount_total / 100 : 0
    
    if (!customerEmail) {
      throw new Error('Customer email is required')
    }

    console.log('Creating order for event:', eventId, 'ticket type:', ticketType)

    // Prepare order data - match the exact column names in your database
    const orderData = {
      "customerEmail": customerEmail,
      "customerName": customerName,
      "stripeSessionId": session.id,
      "status": 'PAID',
      "ticketType": ticketType,
      "quantity": 1, // Default to 1 if not specified
      "amount": parseFloat(amountTotal.toFixed(2)),
      "eventId": eventId,
      "createdAt": new Date().toISOString(),
      "updatedAt": new Date().toISOString()
    }
    
    console.log('Attempting to insert order:', JSON.stringify(orderData, null, 2))
    
    // Insert the order into your database
    const { data: order, error } = await supabase
      .from('orders')
      .insert(orderData)
      .select()
      .single()

    if (error) {
      console.error('Error creating order:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code
      })
      throw error
    }
    
    console.log('Order created successfully:', order)

    // Send confirmation email
    try {
      console.log('Attempting to send confirmation email to:', customerEmail);
      console.log('Using from email: tickets@globalkontaktempire.com');
      
      const emailResult = await fetch('http://localhost:3000/api/test-email');
      const result = await emailResult.json();
      
      if (emailResult.ok) {
        console.log('Test email sent successfully:', result);
      } else {
        console.error('Failed to send test email:', result);
      }
      
      // Send the actual ticket email
      const ticketEmailResult = await fetch('http://localhost:3000/api/send-ticket', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          eventName: event.title,
          eventDate: event.start_date,
          eventLocation: event.venue_name || 'TBD',
          ticketType,
          orderId: order.id,
          attendeeName: customerName || 'Customer',
          attendeeEmail: customerEmail,
          quantity: 1,
          totalAmount: amountTotal.toString()
        })
      });
      
      const ticketResult = await ticketEmailResult.json();
      console.log('Ticket email result:', ticketResult);
    } catch (emailError) {
      console.error('Error sending confirmation email:', emailError);
    }

    return order

  } catch (error) {
    console.error('Error in handleCheckoutSession:', error)
    // Implement proper error handling and retry logic
    throw error
  }
}

// You'll need to implement this function based on your email service
type SendEmailParams = {
  to: string
  name?: string
  eventId: string
  ticketType: string
  amount: number
  bookingId: string
}

async function sendConfirmationEmail(params: SendEmailParams) {
  // Implement your email sending logic here
  // This could use SendGrid, Resend, or any other email service
  console.log('Sending confirmation email to:', params.to)
  
  // Example implementation (you'll need to replace this with your actual email service)
  /*
  const response = await fetch('https://api.your-email-service.com/send', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.EMAIL_API_KEY}`
    },
    body: JSON.stringify({
      to: params.to,
      subject: `Your Ticket Confirmation - Booking #${params.bookingId}`,
      html: `
        <h1>Thank you for your purchase, ${params.name || 'there'}!</h1>
        <p>Your booking has been confirmed.</p>
        <p><strong>Event ID:</strong> ${params.eventId}</p>
        <p><strong>Ticket Type:</strong> ${params.ticketType}</p>
        <p><strong>Amount Paid:</strong> $${params.amount.toFixed(2)}</p>
        <p>You'll receive another email with your ticket details soon.</p>
      `
    })
  })

  if (!response.ok) {
    throw new Error('Failed to send confirmation email')
  }
  */
  
  console.log('Confirmation email sent to:', params.to)
}

export async function paymentLinkWebhook(req: Request) {
  try {
    const body = await req.text()
    const sig = headers().get('stripe-signature')

    if (!sig) {
      return new Response('No signature', { status: 400 })
    }

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET
    if (!webhookSecret) {
      throw new Error('STRIPE_WEBHOOK_SECRET is not set')
    }

    let event
    try {
      event = stripe.webhooks.constructEvent(body, sig, webhookSecret)
    } catch (err: any) {
      console.error(`Webhook Error: ${err.message}`)
      return new Response(`Webhook Error: ${err.message}`, { status: 400 })
    }

    // Handle the checkout.session.completed event
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object as any
      
      // Extract relevant data from the session
      const customerEmail = session.customer_details?.email
      const customerName = session.customer_details?.name || 'Guest'
      const amountTotal = session.amount_total ? (session.amount_total / 100).toFixed(2) : '0.00'
      const metadata = session.metadata || {}
      // Handle both eventId and eventID for backward compatibility
      const eventId = metadata.eventId || metadata.eventID;
      const ticketType = metadata.ticketType || 'standard';
      const quantity = metadata.quantity || '1';

      if (!eventId) {
        console.error('No eventId in session metadata')
        return new Response('Missing eventId in metadata', { status: 400 })
      }

      const supabase = await createServerSupabaseClient()

      // Get event details
      const { data: event, error: eventError } = await supabase
        .from('events')
        .select('*')
        .eq('id', eventId)
        .single()

      if (eventError || !event) {
        console.error('Error fetching event:', eventError)
        return new Response('Event not found', { status: 404 })
      }

      // Create order in database
      console.log('Creating order in database...');
      console.log('Database connection details:', {
        url: process.env.NEXT_PUBLIC_SUPABASE_URL,
        hasServiceKey: !!process.env.SUPABASE_SERVICE_ROLE_KEY
      });
      
      // Prepare order data matching the database schema
      const orderData = {
        "customerEmail": customerEmail,
        "customerName": customerName,
        "stripeSessionId": session.id,
        "status": 'PAID',
        "ticketType": ticketType,
        "quantity": parseInt(quantity) || 1,
        "amount": parseFloat(amountTotal) || 0,
        "eventId": eventId,
        "createdAt": new Date().toISOString(),
        "updatedAt": new Date().toISOString()
      };
      
      console.log('Order data to be inserted:', JSON.stringify(orderData, null, 2));
      
      console.log('Order data to be inserted:', JSON.stringify(orderData, null, 2));
      
      // First, check if order already exists to prevent duplicates
      const { data: existingOrder } = await supabase
        .from('orders')
        .select('*')
        .eq('stripeSessionId', session.id)
        .maybeSingle();
      
      if (existingOrder) {
        console.log('Order already exists with this session ID:', existingOrder.id);
        return new Response(JSON.stringify({ received: true, message: 'Order already processed' }), { status: 200 });
      }
      
      // Insert new order
      console.log('Inserting new order...');
      const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert(orderData)
        .select()
        .single();
        
      if (orderError) {
        console.error('Database error details:', {
          message: orderError.message,
          details: orderError.details,
          hint: orderError.hint,
          code: orderError.code
        });
        return new Response('Failed to create order', { status: 500 });
      }

      // Send confirmation email
      if (order) {
        console.log('=== PREPARING TO SEND EMAIL ===');
        console.log('Order details:', {
          orderId: order.id,
          customerEmail,
          customerName,
          eventId: event.id,
          eventTitle: event.title,
          amount: amountTotal
        });
        
        try {
          if (!process.env.RESEND_API_KEY) {
            console.error('RESEND_API_KEY is not set in environment variables');
          } else if (!customerEmail) {
            console.error('No customer email available to send confirmation');
          } else {
            console.log('Sending email to:', customerEmail);
            const emailResult = await sendTicketEmail({
              eventName: event.title,
              eventDate: event.start_date,
              eventLocation: event.venue_name || 'TBD',
              ticketType,
              orderId: order.id,
              attendeeName: customerName,
              attendeeEmail: customerEmail,
              quantity: parseInt(quantity) || 1,
              totalAmount: amountTotal.toString()
            });
            
            if (emailResult?.success) {
              console.log('Email sent successfully');
            } else {
              console.error('Failed to send email. Error:', emailResult?.error || 'Unknown error');
            }
          }
        } catch (error) {
          console.error('Error sending email:', error);
          // Already responded, just log
        }
      }
      
      return new Response(JSON.stringify({ received: true }), { status: 200 });
    }
    
    return new Response(JSON.stringify({ received: true }), { status: 200 });
    
  } catch (error) {
    console.error('Webhook handler failed:', error);
    return new Response('Webhook handler failed', { status: 400 });
  }
